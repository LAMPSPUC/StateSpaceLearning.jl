<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Add New Models · StateSpaceLearning.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StateSpaceLearning.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../manual/">StateSpaceLearning</a></li><li class="is-active"><a class="tocitem" href>Add New Models</a><ul class="internal"><li><a class="tocitem" href="#Local-Level-Model"><span>Local Level Model</span></a></li><li class="toplevel"><a class="tocitem" href="#Changing-Estimation-Procedure"><span>Changing Estimation Procedure</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Add New Models</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Add New Models</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LAMPSPUC/StateSpaceLearning.jl/blob/main/docs/src/adapting_package.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Add-New-Models"><a class="docs-heading-anchor" href="#Add-New-Models">Add New Models</a><a id="Add-New-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Add-New-Models" title="Permalink"></a></h1><p>The StateSpaceLearning framework supports any additive state space formulation. This section illustrates how to utilize the framework for a specific model.</p><h2 id="Local-Level-Model"><a class="docs-heading-anchor" href="#Local-Level-Model">Local Level Model</a><a id="Local-Level-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Level-Model" title="Permalink"></a></h2><p>Although the Local Level Model is already implemented within the scope of unobserved components, we use it here as an example. To incorporate a new model, it is necessary to create a dictionary containing the model inputs and another dictionary containing three functions (create_X, get_components_indexes, and get_variances).</p><h3 id="Model-Inputs"><a class="docs-heading-anchor" href="#Model-Inputs">Model Inputs</a><a id="Model-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Inputs" title="Permalink"></a></h3><p>For the Local Level Model, no parameters are needed. Thus, the model input can be created as:</p><pre><code class="language-julia hljs">model_input = Dict()</code></pre><h3 id="create_X"><a class="docs-heading-anchor" href="#create_X">create_X</a><a id="create_X-1"></a><a class="docs-heading-anchor-permalink" href="#create_X" title="Permalink"></a></h3><p>The create_X function constructs the matrices in the State Space Learning format. It must accept the following inputs: (model_input::Dict, Exogenous_X::Matrix{Fl}, steps_ahead::Int64=0, Exogenous_Forecast::Matrix{Fl}). It must return a matrix.</p><pre><code class="language-julia hljs">function create_X_LocalLevel(model_input::Dict, Exogenous_X::Matrix{Fl},
                  steps_ahead::Int64=0, Exogenous_Forecast::Matrix{Fl}=zeros(steps_ahead, size(Exogenous_X, 2))) where Fl
    T = size(Exogenous_X, 1)
    initial_states_matrix = ones(T+steps_ahead, 1)
    ξ_matrix = Matrix{Float64}(undef, T+steps_ahead, T - 1)
    for t in 1:T+steps_ahead
        ξ_matrix[t, :] = t &lt; T ? vcat(ones(t-1), zeros(T-t)) : ones(T-1)
    end
    
    return hcat(initial_states_matrix, ξ_matrix)
end</code></pre><h3 id="get_components_indexes"><a class="docs-heading-anchor" href="#get_components_indexes">get_components_indexes</a><a id="get_components_indexes-1"></a><a class="docs-heading-anchor-permalink" href="#get_components_indexes" title="Permalink"></a></h3><p>The get_components_indexes function outputs a dictionary indicating the indexes of each model component, including a set of indexes for all initial states. For the Local Level Model, the only components are the initial state μ1 and its innovations ξ. The function must accept the following inputs: (Exogenous_X::Matrix{Fl}, model_input::Dict). It must return a dictionary.</p><pre><code class="language-julia hljs">function get_components_indexes_LocalLevel(Exogenous_X::Matrix{Fl}, model_input::Dict)::Dict where Fl
    T = size(Exogenous_X, 1)
    μ1_indexes = [1]
    initial_states_indexes = [1]
    ξ_indexes = collect(2:T)
    return Dict(&quot;μ1&quot; =&gt; μ1_indexes, &quot;ξ&quot; =&gt; ξ_indexes, &quot;initial_states&quot; =&gt; initial_states_indexes)
end</code></pre><h3 id="get_variances"><a class="docs-heading-anchor" href="#get_variances">get_variances</a><a id="get_variances-1"></a><a class="docs-heading-anchor-permalink" href="#get_variances" title="Permalink"></a></h3><p>The get_variances function calculates the variances of the innovations and residuals. It must accept the following inputs:(ε::Vector{Fl}, coefs::Vector{Fl}, components_indexes::Dict{String, Vector{Int64}}). It must return a dictionary.</p><pre><code class="language-julia hljs">function get_variances_LocalLevel(ε::Vector{Fl}, coefs::Vector{Fl}, components_indexes::Dict{String, Vector{Int64}})::Dict where Fl
    
    variances = Dict()
    variances[&quot;ξ&quot;] = var(coefs[components_indexes[&quot;ξ&quot;]])
    variances[&quot;ε&quot;] = var(ε)
    return variances
end</code></pre><h3 id="Running-the-new-model"><a class="docs-heading-anchor" href="#Running-the-new-model">Running the new model</a><a id="Running-the-new-model-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-new-model" title="Permalink"></a></h3><p>To test the new model, run the fit_model function with the new inputs:</p><pre><code class="language-julia hljs">using StateSpaceLearning
using Statistics

y = randn(100)

#Fit Model
output = StateSpaceLearning.fit_model(y; model_input = model_input, model_functions = Dict(&quot;create_X&quot; =&gt; create_X_LocalLevel, 
                                       &quot;get_components_indexes&quot; =&gt;   get_components_indexes_LocalLevel, &quot;get_variances&quot; =&gt; get_variances_LocalLevel))</code></pre><h1 id="Changing-Estimation-Procedure"><a class="docs-heading-anchor" href="#Changing-Estimation-Procedure">Changing Estimation Procedure</a><a id="Changing-Estimation-Procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Changing-Estimation-Procedure" title="Permalink"></a></h1><p>The current estimation procedure is based on an Adaptive Lasso. However, alternative methods can be chosen within the StateSpaceLearning framework. Below is an example of how to implement a simple model that minimizes the sum of squares of the residuals. This requires creating two variables: a dictionary estimation_input (which is empty in this case) and a function estimation_function with the following arguments:(Estimation<em>X::Matrix{Tl}, estimation\</em>y::Vector{Fl}, components_indexes::Dict{String, Vector{Int64}}, estimation_input::Dict). The function should return a tuple containing the model coefficients and residuals.</p><pre><code class="language-julia hljs">estimation_input = Dict()
function estimation_function_min_sq(Estimation_X::Matrix{Tl}, estimation_y::Vector{Fl}, components_indexes::Dict{String, Vector{Int64}}, estimation_input::Dict) where {Tl, Fl}
    mq_coefs = Estimation_X \ estimation_y
    mq_res = estimation_y - (Estimation_X * mq_coefs)
    return mq_coefs, mq_res
end</code></pre><h3 id="Running-the-model-with-the-new-estimation-procedure"><a class="docs-heading-anchor" href="#Running-the-model-with-the-new-estimation-procedure">Running the model with the new estimation procedure</a><a id="Running-the-model-with-the-new-estimation-procedure-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-model-with-the-new-estimation-procedure" title="Permalink"></a></h3><pre><code class="language-julia hljs">using StateSpaceLearning

y = randn(100)

#Fit Model
output = StateSpaceLearning.fit_model(y; estimation_input = estimation_input, estimation_function = estimation_function_min_sq)</code></pre><p>By following these steps, you can customize and extend the StateSpaceLearning framework to suit a variety of state space models and estimation procedures.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual/">« StateSpaceLearning</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 26 August 2024 19:54">Monday 26 August 2024</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
